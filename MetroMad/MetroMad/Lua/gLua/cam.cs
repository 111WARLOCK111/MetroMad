//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34014
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// /*  AutoGeneratedCode.cs - This class Is autogenerated.
//
//    Copyright (C) 2014  Ali Deym (https://github.com/111WARLOCK111/).
//
//    This program is free software; you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation; either version 2 of the License, or
//    (at your option) any later version.
//
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License along
//    with this program; if not, write to the Free Software Foundation, Inc.,
//    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
//*/
namespace MetroMad.Lua.gLua {
    using System;
    
    
    public class cam {
        
        // <realm>Client</realm>
        // <summary>Shakes the screen at a certain position.</summary>
        // <param name="pos">Origin of the shake.</param>
        // <param name="angles">Angles of the shake.</param>
        // <param name="factor">The shake factor.</param>
        public static void ApplyShake(Vector pos, Angle angles, float factor) {
        }
        
        // <realm>Client</realm>
        // <summary>Switches the renderer back to the previous drawing mode from a 2D or 3D context.</summary>
        public static void End() {
        }
        
        // <realm>Client</realm>
        // <summary>Switches the renderer back to the previous drawing mode from a 2D context.</summary>
        public static void End2D() {
        }
        
        // <realm>Client</realm>
        // <summary>Switches the renderer back to the previous drawing mode from a 3D context.</summary>
        public static void End3D() {
        }
        
        // <realm>Client</realm>
        // <summary>Switches the renderer back to the previous drawing mode from a 3D2D context.</summary>
        public static void End3D2D() {
        }
        
        // <realm>Client</realm>
        // <summary>Switches the renderer back to the previous drawing mode from a 3D orthographic rendering context.</summary>
        public static void EndOrthoView() {
        }
        
        // <realm>Client</realm>
        // <summary>Tells the renderer to ignore the depth buffer and draw any upcoming operation "ontop" of everything that was drawn yet.</summary>
        // <param name="ignoreZ">Determines whenever to ignore the depth buffer or not.</param>
        public static void IgnoreZ(bool ignoreZ) {
        }
        
        // <realm>Client</realm>
        // <summary>Pops the current active rendering matrix from the stack and reinstates the previous one.</summary>
        public static void PopModelMatrix() {
        }
        
        // <realm>Client</realm>
        // <summary>Pushes the specified matrix onto the render matrix stack.</summary>
        // <param name="matrix">The matrix to push.</param>
        public static void PushModelMatrix(VMatrix matrix) {
        }
        
        // <realm>Client</realm>
        // <summary>Sets up a new rendering context. You can easily use this instead of {{LibraryFunction|cam|Start3D}} or {{LibraryFunction|cam|Start2D}}</summary>
        // <param name="dataTbl">Render context config. See {{Struct|RenderCamData}}.</param>
        public static void Start(table dataTbl) {
        }
        
        // <realm>Client</realm>
        // <summary>Sets up a new 2D rendering context.</summary>
        public static void Start2D() {
        }
        
        // <realm>Client</realm>
        // <summary>Sets up a new 3D rendering context.</summary>
        // <param name="pos">Render cam position.</param>
        // <param name="angles">Render cam angles.</param>
        // <param name="fov">Field of view. Optional.</param>
        // <param name="x">X coordinate of where to start the new view port. Optional.</param>
        // <param name="y">Y coordinate of where to start the new view port. Optional.</param>
        // <param name="w">Width of the new viewport. Optional.</param>
        // <param name="h">Height of the new viewport. Optional.</param>
        // <param name="zNear">Distance to near clipping plane. Optional.</param>
        // <param name="zFar">Distance to far clipping plane. Optional.</param>
        public static void Start3D(Vector pos, Angle angles, float fov, float x, float y, float w, float h, float zNear, float zFar) {
        }
        
        // <realm>Client</realm>
        // <summary>Sets up a new 3D2D rendering context.</summary>
        // <param name="pos">Origin of the 3D2D context, ie. the top left corner, (0, 0).</param>
        // <param name="angles">Angles of the 3D2D context.</param>
        // <param name="scale">The scale of the render context.</param>
        public static void Start3D2D(Vector pos, Angle angles, float scale) {
        }
        
        // <realm>Client</realm>
        // <summary>Sets up a new 3d context using orthographic projection.</summary>
        // <param name="leftOffset">The left plane offset.</param>
        // <param name="topOffset">The top plane offset.</param>
        // <param name="rightOffset">The right plane offset.</param>
        // <param name="bottomOffset">The bottom plane offset.</param>
        public static void StartOrthoView(float leftOffset, float topOffset, float rightOffset, float bottomOffset) {
        }
    }
}
